// flow-typed signature: c4405dcb6147b12df0992e62204e630c
// flow-typed version: <<STUB>>/yup_v0.25.1/flow_v0.73.0

/**
 * This is an autogenerated libdef stub for:
 *
 *   'yup'
 *
 * Fill this stub out by replacing all the `any` types.
 *
 * Once filled out, we encourage you to share your work with the
 * community by sending a pull request to:
 * https://github.com/flowtype/flow-typed
 */

declare module 'yup' {
  declare type ValidateOptions = {
    strict?: boolean,
    abortEarly?: boolean,
    stripUnknown?: boolean,
    recursive?: boolean,
    context?: any
  };

  declare type ValidationError = {
    errors: string | string[],
    value: any,
    path: string,
    type?: any,
    inner: Array<ValidationError>,
    message: string,
  };

  declare type SchemaDescription = {
    type: string,
    label: string,
    meta: string,
    tests: string[]
  };

  declare type WhenOptionsBuilder<T> = {
    (value: any, schema: T): T,
    (v1: any, v2: any, schema: T): T,
    (v1: any, v2: any, v3: any, schema: T): T,
    (v1: any, v2: any, v3: any, v4: any, schema: T): T
  };

  declare type WhenOptions<T> =
    | WhenOptionsBuilder<T>
    | {
        is: boolean | ((value: any) => boolean),
        then: any,
        otherwise: any
      };

  declare type TestOptions = {
    name?: string,
    test: (value: any) => boolean,
    message?: string,
    params?: any,
    exclusive?: boolean
  };

  declare type TransformFunction<T> = (
    schema: T,
    value: any,
    originalValue: any
  ) => any;

  declare interface $Schema {
    shape(fields: any, noSortEdges?: Array<[string, string]>): Schema,
    clone(): Schema,
    label(label: string): Schema,
    meta(metadata: any): Schema,
    meta(): any,
    describe(): SchemaDescription,
    concat(schema: Schema): Schema,
    validate<U>(
      value: U,
      options?: ValidateOptions
    ): Promise<ValidationError | U>,
    validateSync<U>(value: U, options?: ValidateOptions): ValidationError | U,
    isValid(value: any, options?: any): Promise<boolean>,
    isValidSync(value: any, options?: any): boolean,
    cast(value: any, options?: any): any,
    isType(value: any): boolean,
    strict(isStrict: boolean): Schema,
    strip(strip: boolean): Schema,
    withMutation(fn: (current: Schema) => void): void,
    default(value?: any): Schema,
    nullable(isNullable: boolean): Schema,
    required(message?: string): Schema,
    typeError(message?: string): Schema,
    oneOf(arrayOfValues: any[], message?: string): Schema,
    notOneOf(arrayOfValues: any[], message?: string): Schema,
    when(keys: string | any[], builder: WhenOptions<Schema>): Schema,
    test(
      name: string,
      message: string,
      test: (value?: any) => boolean,
      callbackStyleAsync?: boolean
    ): Schema,
    test(options: TestOptions): Schema,
    transform(fn: TransformFunction<Schema>): Schema
  }

  declare type MatchesOptions = {
    message: string,
    excludeEmptyString: bool,
  };

  declare interface $StringSchema extends Schema {
    required(message: ?string): $StringSchema,
    min(limit: number, message: ?string): $StringSchema,
    max(limit: number, message: ?string): $StringSchema,
    matches(regex: RegExp, message: ?string): $StringSchema,
    matches(regex: RegExp, options: MatchesOptions): $StringSchema,
    email(message: ?string): $StringSchema,
    url(message: ?string): $StringSchema,
    ensure(): $StringSchema,
    trim(message: ?string): $StringSchema,
    lowercase(message: ?string): $StringSchema,
    uppercase(message: ?string): $StringSchema,
  }

  declare interface $DateSchema extends Schema {
    min(limit: Date | string, message: ?string): $DateSchema,
    max(limit: Date | string, message: ?string): $DateSchema,
  }

  declare type RoundTypes = 'floor' | 'ceil' | 'trunc' | 'round';

  declare interface $NumberSchema extends Schema {
    min(limit: number, message: ?string): $NumberSchema,
    max(limit: number, message: ?string): $NumberSchema,
    lessThan(max: number, message: ?string): $NumberSchema,
    moreThan(min: number, message: ?string): $NumberSchema,
    positive(message: ?string): $NumberSchema,
    negative(message: ?string): $NumberSchema,
    integer(message: ?string): $NumberSchema,
    truncate(): $NumberSchema,
    round(type: ?RoundTypes): $NumberSchema,
  }

  declare type RejectorType = (value: any) => boolean;

  declare interface $ArraySchema extends Schema {
    of(type: Schema): $ArraySchema,
    required(message: ?string): $ArraySchema,
    min(limit: number, message: ?string): $ArraySchema,
    max(limit: number, message: ?string): $ArraySchema,
    ensure(): $ArraySchema,
    compact(rejector: RejectorType): $ArraySchema,
  }

  declare type Schema = $Schema;
  declare type StringSchema = $StringSchema;
  declare type DateSchema = $DateSchema;
  declare type NumberSchema = $NumberSchema;
  declare type ArraySchema = $ArraySchema;

  declare type Yup = {
    object(obj?: Object): Schema,
    string(): $StringSchema,
    date(): $DateSchema,
    mixed(): Schema,
    number(): $NumberSchema,
    boolean(): Schema,
    array(): $ArraySchema,
    reach(schema: Schema, path: string, value: ?Object, context: ?Object): Schema,
  };

  declare module.exports: Yup;
}
